# Embedded Inference Export (Logistic Regression)

This document describes how to deploy the trained Machine Learning model
(from `notebooks/01_data_preprocessing.ipynb`)
onto an embedded / firmware / ECU environment.

The model was trained using **scikit-learn** in Python.
Inference on embedded targets is implemented as **pure arithmetic**
(no ML libraries required).

---

## 1. Model Overview

- **Task**: Binary classification
- **Target**: `Purchased` → Yes / No
- **Model**: Logistic Regression
- **Preprocessing**:
  - StandardScaler for numeric features
  - OneHotEncoding for categorical feature (`Country`, drop="first")

Training code lives in Python.
Inference code is implemented in C/C++ using exported constants.

---

## 2. Input / Output Interface

### Input format

Country,Age,Salary


Example:
Spain,27.0,48000.0


### Output

- `"Yes"` → Purchased
- `"No"`  → Not Purchased

On embedded targets, this is typically returned as:
- `1` → Yes
- `0` → No

---

## 3. Feature Engineering (must exactly match training)

### Feature order (CRITICAL)

The trained model expects features in this exact order:

1. `Age` (scaled)
2. `Salary` (scaled)
3. `Country_Germany`
4. `Country_Spain`

This order must not be changed.

---

### 3.1 Numeric preprocessing (StandardScaler)

Numeric features were standardized during training using:

z = (x - mean) / std


#### Constants (from training data)

```c
AGE_MEAN    = 39.0
AGE_STD     = 7.664854858377946

SALARY_MEAN = 64847.22222222222
SALARY_STD  = 11430.808691675275
```
Embedded implementation must use these exact constants.

### 3.2 Categorical preprocessing (OneHotEncoder, drop="first")
Baseline category: France

Encoding rules:

| Country  | Country_Germany | Country_Spain |
|----------|:---------------:|:-------------:|
| France   |        0        |       0       |
| Germany  |        1        |       0       |
| Spain    |        0        |       1       |


## 4. Logistic Regression Parameters
Learned coefficients
```c
W0 = -0.11365409190612158   // Age (scaled)
W1 = -0.24988367603889020   // Salary (scaled)
W2 = -0.33414159899020630   // Country_Germany
W3 = -0.15974441724978910   // Country_Spain

B  =  0.16318800946443990   // Bias
```
## 5. Inference Formula
Linear score
```c
score = B
      + W0 * age_scaled
      + W1 * salary_scaled
      + W2 * isGermany
      + W3 * isSpain;
```
Probability (sigmoid)
```c
p = 1 / (1 + exp(-score));
```
Classification rule
```c
if (p >= 0.5)
    return 1;   // "Yes"
else
    return 0;   // "No"
```
## 6. Reference Embedded C Implementation
```c
#include <math.h>
#include <string.h>

static const double W0 = -0.11365409190612158;
static const double W1 = -0.24988367603889020;
static const double W2 = -0.33414159899020630;
static const double W3 = -0.15974441724978910;
static const double B  =  0.16318800946443990;

static const double AGE_MEAN    = 39.0;
static const double AGE_STD     = 7.664854858377946;
static const double SALARY_MEAN = 64847.22222222222;
static const double SALARY_STD  = 11430.808691675275;

static double sigmoid(double x) {
    if (x >= 0.0) {
        double z = exp(-x);
        return 1.0 / (1.0 + z);
    } else {
        double z = exp(x);
        return z / (1.0 + z);
    }
}

// Returns 1 = "Yes", 0 = "No"
int predict_purchased(const char* country, double age, double salary) {

    // One-hot encoding (France is baseline)
    double isGermany = (strcmp(country, "Germany") == 0) ? 1.0 : 0.0;
    double isSpain   = (strcmp(country, "Spain")   == 0) ? 1.0 : 0.0;

    // StandardScaler
    double age_scaled    = (age    - AGE_MEAN)    / AGE_STD;
    double salary_scaled = (salary - SALARY_MEAN) / SALARY_STD;

    // Logistic regression
    double score = B
        + W0 * age_scaled
        + W1 * salary_scaled
        + W2 * isGermany
        + W3 * isSpain;

    double p = sigmoid(score);
    return (p >= 0.5) ? 1 : 0;
}
```

## 7. Notes for Embedded Targets
Floating point can be converted to `float` if required

`exp()` can be approximated for MCUs if needed

No dynamic memory allocation is required

Model inference cost is O(1)

## 8. Ownership & Traceability
Training & validation: Python / scikit-learn

Inference: Embedded C/C++

Source of truth:

01_data_preprocessing.ipynb

02_inference_autogenerated.ipynb

This document represents the official ML → firmware handover.
